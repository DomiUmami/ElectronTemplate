# p-try [![Build Status](https://travis-ci.org/sindresorhus/p-try.svg?branch=master)](https://travis-ci.org/sindresorhus/p-try)

<<<<<<< HEAD
> Start a promise chain
=======
> [`Promise#try()`](https://github.com/ljharb/proposal-promise-try) [ponyfill](https://ponyfill.com) - Starts a promise chain
>>>>>>> de4d53c276c42b132f5ecc6af6fe57f59159636b

[How is it useful?](http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/)


## Install

```
<<<<<<< HEAD
$ npm install p-try
=======
$ npm install --save p-try
>>>>>>> de4d53c276c42b132f5ecc6af6fe57f59159636b
```


## Usage

```js
const pTry = require('p-try');

<<<<<<< HEAD
(async () => {
	try {
		const value = await pTry(() => {
			return synchronousFunctionThatMightThrow();
		});
		console.log(value);
	} catch (error) {
		console.error(error);
	}
})();
```


## API

### pTry(fn, ...arguments)

Returns a `Promise` resolved with the value of calling `fn(...arguments)`. If the function throws an error, the returned `Promise` will be rejected with that error.

Support for passing arguments on to the `fn` is provided in order to be able to avoid creating unnecessary closures. You probably don't need this optimization unless you're pushing a *lot* of functions.

#### fn

The function to run to start the promise chain.

#### arguments

Arguments to pass to `fn`.


=======
pTry(() => {
	return synchronousFunctionThatMightThrow();
}).then(value => {
	console.log(value);
}).catch(error => {
	console.error(error);
});
```


>>>>>>> de4d53c276c42b132f5ecc6af6fe57f59159636b
## Related

- [p-finally](https://github.com/sindresorhus/p-finally) - `Promise#finally()` ponyfill - Invoked when the promise is settled regardless of outcome
- [More…](https://github.com/sindresorhus/promise-fun)


## License

MIT © [Sindre Sorhus](https://sindresorhus.com)
